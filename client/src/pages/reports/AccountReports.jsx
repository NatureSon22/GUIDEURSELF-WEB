import Header from "@/components/Header";
import ComboBox from "@/components/ComboBox";
import { useState, useMemo } from "react";
import { getLowAccounts } from "@/api/accounts";
import { getAllCampuses, getLowRoleTypes } from "@/api/component-info";
import { useQuery } from "@tanstack/react-query";
import formatDate from "@/utils/formatDate";
import accountStatus from "@/utils/accountStatus";
import { Button } from "@/components/ui/button";
import { GrPowerReset } from "react-icons/gr";
import DataTable from "@/components/DataTable";
import columns from "@/components/columns/UserReport";
import Loading from "@/components/Loading";
import { LuDownload } from "react-icons/lu";
import jsPDF from "jspdf";
import "jspdf-autotable";
import PdfPreviewModal from "./PdfPreviewModal";
import { vectorUrl, logoUrl, tagline } from "./info.js";
import { loggedInUser } from "@/api/auth";
import { Input } from "@/components/ui/input";
import FeaturePermission from "@/layer/FeaturePermission";

const AccountReports = () => {
  const [filters, setFilters] = useState([]);
  const [globalFilter, setGlobalFilter] = useState("");
  const [reset, setReset] = useState(false);
  const [pdfPreviewUrl, setPdfPreviewUrl] = useState(null);
  const [fromDate, setFromDate] = useState(""); // New state for From date
  const [toDate, setToDate] = useState(""); // New state for To date

  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: loggedInUser,
    refetchOnWindowFocus: false,
  });

  const { data: allAccounts, isLoading } = useQuery({
    queryKey: ["accounts"],
    queryFn: getLowAccounts,
    refetchOnWindowFocus: false,
  });

  const { data: allCampuses } = useQuery({
    queryKey: ["allCampuses"],
    queryFn: getAllCampuses,
  });

  const { data: allRoles } = useQuery({
    queryKey: ["allRoles"],
    queryFn: getLowRoleTypes,
  });

  // Filter accounts based on selected date range and filters
  const filteredAccounts = useMemo(() => {
    if (!allAccounts) return [];

    return allAccounts.filter((account) => {
      const matchesFilters = filters.every((filter) => {
        if (filter.value === "") return true;
        const accountValue = account[filter.id];
        return (
          accountValue &&
          accountValue.toLowerCase() === filter.value.toLowerCase()
        );
      });

      const accountDate = new Date(account.date_updated);
      const from = fromDate ? new Date(fromDate) : null;
      const to = toDate ? new Date(toDate) : null;

      const matchesDateRange =
        (!from || accountDate >= from) && (!to || accountDate <= to);

      return matchesFilters && matchesDateRange;
    });
  }, [allAccounts, filters, fromDate, toDate]);

  const handleReset = () => {
    setFilters([]);
    setGlobalFilter("");
    setReset(!reset);
    setFromDate(""); // Clear From Date
    setToDate(""); // Clear To Date
  };

  const handleGeneratePDF = (preview = false) => {
    if (!filteredAccounts || filteredAccounts.length === 0) {
      alert("No data available to generate PDF.");
      return;
    }

    const doc = new jsPDF({ orientation: "landscape" });
    const today = new Date().toLocaleDateString("en-US");

    const imgWidth = 12;
    const imgHeight = 12;

    const addHeader = () => {
      doc.addImage(logoUrl, "PNG", 13, 22, 12, 12.5);
      doc.addImage(tagline, "PNG", 40, 22, 67, 13.5);
      doc.addImage(vectorUrl, "PNG", 26, 22, imgWidth, imgHeight);

      doc.setLineWidth(0.1);
      doc.line(14, 37, 285, 37);

      doc.setLineWidth(0.1);
      doc.line(14, 36.3, 285, 36.3);

      const pageWidth = doc.internal.pageSize.width; // Get the width of the page

      doc.setFontSize(10);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(0, 0, 0);
      doc.text("Showing result of:", 243 + imgWidth + 0, 23);

      // Text 2: "Generated By: ${data.firstname} ${data.lastname}"
      const text2 = `Generated By: ${data.firstname} ${data.lastname}`;
      const textWidth2 =
        (doc.getStringUnitWidth(text2) * doc.internal.getFontSize()) /
        doc.internal.scaleFactor;
      const xPos2 = pageWidth - textWidth2 - 14; // 10 is for padding from the right edge

      doc.setFontSize(10);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(0, 0, 0);
      doc.text(text2, xPos2, 28);

      // Text 3: "Date Range: ${fromDate || today} - ${toDate || today}"
      const text3 = `Date from: ${fromDate || today} - ${toDate || today}`;
      const textWidth3 =
        (doc.getStringUnitWidth(text3) * doc.internal.getFontSize()) /
        doc.internal.scaleFactor;
      const xPos3 = pageWidth - textWidth3 - 14; // 10 is for padding from the right edge

      doc.setFontSize(10);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(0, 0, 0);
      doc.text(text3, xPos3, 33);

      doc.setFontSize(13);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(0, 0, 0);
      doc.text("GUIDEURSELF", 107.5 + imgWidth + 10, 45);

      doc.setFontSize(13);
      doc.setFont("helvetica", "normal");
      doc.setTextColor(0, 0, 0);
      doc.text("User Account Report", 104 + imgWidth + 10, 50);
    };

    const addFooter = (pageNumber) => {
      doc.line(14, 195, 285, 195);
      doc.setFontSize(10).setFont("helvetica", "normal").setTextColor(100);
      doc.text(``, 140, 200);
      doc.text(`Page ${pageNumber} | Generated on: ${today}`, 232, 200);
      doc.text(`CONFIDENTIAL - For internal use only`, 14, 200);
    };

    addHeader();

    const tableData = filteredAccounts.map((account) => [
      account.user_number,
      account.username,
      account.firstname,
      account.lastname,
      account.role_type,
      account.campus_name,
      formatDate(account.date_created),
      formatDate(account.date_assigned),
      account.status.charAt(0).toUpperCase() + account.status.slice(1),
    ]);

    const rowsPerPage = 16;
    const totalPages = Math.ceil(tableData.length / rowsPerPage);

    for (let i = 0; i < totalPages; i++) {
      if (i > 0) {
        doc.addPage();
        addHeader();
      }

      const chunk = tableData.slice(i * rowsPerPage, (i + 1) * rowsPerPage);
      doc.autoTable({
        head: [
          [
            "USER ID",
            "USERNAME",
            "FIRSTNAME",
            "LASTNAME",
            "USER TYPE",
            "CAMPUS",
            "DATE CREATED",
            "DATE UPDATED",
            "STATUS",
          ],
        ],
        body: chunk,
        startY: 55,
        didDrawPage: (data) => addFooter(doc.internal.getNumberOfPages()),

        // Modify border settings
        styles: {
          halign: "center", // Center the text in cells
          valign: "middle", // Vertical alignment (optional)
          lineWidth: 0.2, // Border line width
          lineColor: [0, 0, 0], // Black border
        },
        headStyles: {
          halign: "center", // Center the header text
          fontSize: 9,
          fontStyle: "bold",
          textColor: [0, 0, 0],
          fillColor: [222, 234, 246],
        },
        bodyStyles: {
          halign: "center", // Center the body text
          fillColor: [255, 255, 255], // Set body rows background color to white (RGB)
        },
        tableWidth: "auto",
      });
    }

    if (preview) {
      const pdfBlob = doc.output("blob");
      const pdfUrl = URL.createObjectURL(pdfBlob);

      window.open(pdfUrl, "_blank");
    } else {
      doc.save("user_account_report.pdf");
    }
  };

  return (
    <div className="flex flex-1 flex-col gap-5">
      <Header
        title="User Account Report"
        subtitle="Access, review, and generate reports on user account records"
      />

      <div className="flex flex-col gap-5">
        <div className="flex items-center gap-5">
          <p>Filters:</p>
          <Input
            type="date"
            className="w-[170px]"
            value={fromDate}
            onChange={(e) => setFromDate(e.target.value)}
          />
          <Input
            type="date"
            className="w-[170px]"
            value={toDate}
            onChange={(e) => setToDate(e.target.value)}
          />
          <ComboBox
            options={allRoles}
            placeholder="Select user type"
            filter="role_type"
            setFilters={setFilters}
            reset={reset}
          />
          <ComboBox
            options={allCampuses}
            placeholder="Select campus"
            filter="campus_name"
            setFilters={setFilters}
            reset={reset}
          />
          <ComboBox
            options={accountStatus}
            placeholder="Select status"
            filter="status"
            setFilters={setFilters}
            reset={reset}
          />
          <Button
            className="text-secondary-100-75"
            variant="outline"
            onClick={handleReset}
          >
            <GrPowerReset /> Reset Filters
          </Button>
          <div className="ml-auto space-x-5">
            <Button
              variant="ghost"
              className="text-base-200"
              onClick={() => handleGeneratePDF(true)}
            >
              File Preview
            </Button>
            <FeaturePermission module="Manage Reports" access="generate report">
              <Button
                className="border border-base-200 bg-base-200/10 text-base-200 hover:bg-base-200 hover:text-white"
                onClick={() => handleGeneratePDF(false)}
              >
                <LuDownload /> Download
              </Button>
            </FeaturePermission>
          </div>
        </div>
      </div>

      {isLoading ? (
        <Loading />
      ) : (
        <DataTable
          data={filteredAccounts}
          columns={columns}
          filters={filters}
          setFilters={setFilters}
          pageSize={11}
          globalFilter={globalFilter}
          setGlobalFilter={setGlobalFilter}
        />
      )}

      {pdfPreviewUrl && (
        <PdfPreviewModal
          pdfUrl={pdfPreviewUrl}
          onClose={() => setPdfPreviewUrl(null)}
        />
      )}
    </div>
  );
};

export default AccountReports;
